// Generated by LiveScript 1.2.0
(function(){
  'use strict';
  var map, desertMap, tileset, layer, player, group, cursors, oldY, preload, create, update, createTrees, g;
  map = require('prelude-ls').map;
  oldY = 0;
  preload = function(){
    g.load.image('phaser', '../../../phaser/examples/assets/sprites/phaser-dude.png');
    g.load.tilemap('desert', '../../../phaser/examples/assets/tilemaps/maps/depthsort.json', null, Phaser.Tilemap.TILED_JSON);
    g.load.image('ground_1x1', '../../../phaser/examples/assets/tilemaps/tiles/ground_1x1.png');
    return g.load.spritesheet('trees', '../../../phaser/examples/assets/tilemaps/tiles/walls_1x2.png', 32, 64);
  };
  create = function(){
    var desertMap, layer;
    desertMap = g.add.tilemap('desert');
    desertMap.addTilesetImage('ground_1x1');
    layer = desertMap.createLayer('Tile Layer 1');
    layer.resizeWorld();
    group = g.add.group();
    player = group.create(300, 200, 'phaser');
    map(createTrees, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49]);
    return cursors = g.input.keyboard.createCursorKeys();
  };
  update = function(){
    var oldY;
    player.body.velocity.x = 0;
    player.body.velocity.y = 0;
    if (cursors.left.isDown) {
      player.body.velocity.x = -200;
    } else if (cursors.right.isDown) {
      player.body.velocity.x = 200;
    }
    if (cursors.up.isDown) {
      player.body.velocity.y = -200;
    } else if (cursors.down.isDown) {
      player.body.velocity.y = 200;
    }
    if (!deepEq$(player.y, oldY, '===')) {
      group.sort();
      return oldY = player.y;
    }
  };
  createTrees = function(i){
    var x, y;
    x = g.math.snapTo(g.world.randomX, 32);
    y = g.math.snapTo(g.world.randomY, 32);
    return group.create(x, y, 'trees', g.rnd.integerInRange(0, 8));
  };
  g = new Phaser.Game(800, 600, Phaser.CANVAS, '', {
    preload: preload,
    create: create,
    update: update
  });
  function deepEq$(x, y, type){
    var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,
        has = function (obj, key) { return hasOwnProperty.call(obj, key); };
    var first = true;
    return eq(x, y, []);
    function eq(a, b, stack) {
      var className, length, size, result, alength, blength, r, key, ref, sizeB;
      if (a == null || b == null) { return a === b; }
      if (a.__placeholder__ || b.__placeholder__) { return true; }
      if (a === b) { return a !== 0 || 1 / a == 1 / b; }
      className = toString.call(a);
      if (toString.call(b) != className) { return false; }
      switch (className) {
        case '[object String]': return a == String(b);
        case '[object Number]':
          return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
        case '[object Date]':
        case '[object Boolean]':
          return +a == +b;
        case '[object RegExp]':
          return a.source == b.source &&
                 a.global == b.global &&
                 a.multiline == b.multiline &&
                 a.ignoreCase == b.ignoreCase;
      }
      if (typeof a != 'object' || typeof b != 'object') { return false; }
      length = stack.length;
      while (length--) { if (stack[length] == a) { return true; } }
      stack.push(a);
      size = 0;
      result = true;
      if (className == '[object Array]') {
        alength = a.length;
        blength = b.length;
        if (first) { 
          switch (type) {
          case '===': result = alength === blength; break;
          case '<==': result = alength <= blength; break;
          case '<<=': result = alength < blength; break;
          }
          size = alength;
          first = false;
        } else {
          result = alength === blength;
          size = alength;
        }
        if (result) {
          while (size--) {
            if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }
          }
        }
      } else {
        if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) {
          return false;
        }
        for (key in a) {
          if (has(a, key)) {
            size++;
            if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }
          }
        }
        if (result) {
          sizeB = 0;
          for (key in b) {
            if (has(b, key)) { ++sizeB; }
          }
          if (first) {
            if (type === '<<=') {
              result = size < sizeB;
            } else if (type === '<==') {
              result = size <= sizeB
            } else {
              result = size === sizeB;
            }
          } else {
            first = false;
            result = size === sizeB;
          }
        }
      }
      stack.pop();
      return result;
    }
  }
}).call(this);
